
#!/usr/bin/env python3
"""
Recover the 27-byte flag from the runtime dump `goal.bin`.

# What we dumped (from radare2 while hitting the r9 blob breakpoint)
- Seed (4 bytes, LE) at r9:      `p8 4 @ r9`  -> fe 0f dc ba  == 0xBADC0FFE
- VM length (1 byte) at r9+4:    `p8 1 @ r9+4` -> 0x36
- Masked goal (32 bytes) at:     `wtf goal.bin 0x20 @ r9+5+0x36`

You do NOT need the VM bytecode to recover the flag.

# Why this works (quick map to the decompiler)
- The program builds a PRNG S-box from `seed` (xorshift32 + Fisher-Yates).
  Ghidra: `if (uVar39 == 0) { uVar39 = 0xc001d00d; }` then xorshift loop + swap.
- It creates a 32-byte table from the S-box and XORs it with 0x5A.
  (Net effect for us: init_mem[i] = SBOX[i] ^ 0x5A)
- For each of the first 27 bytes, it XORs the table with (SBOX(input[i]) ^ 0xA5).
- Finally it compares the result to an “expected” 32-byte buffer, but with a mask:
    mask[i] = ((0xA6 + 13*i) & 0xFF) ^ 0x3C
  Decompiler loop:
    imul eax, 0x0d; sub 0x5a; xor [rbp+rdx]; xor 0x3c; cmp al, [rsi+rdx]

So if we:
  1) unmask the dumped goal (remove the per-index mask),
  2) subtract the 32-byte init table (SBOX[i] ^ 0x5A),
  3) invert the S-box,

…we recover the original 27 input bytes (the flag).
"""

from pathlib import Path

# ---- inputs you already dumped in r2 ----
GOAL_PATH = Path("goal.bin")     # 32 masked bytes from: wtf goal.bin 0x20 @ r9+5+0x36
SEED      = 0xBADC0FFE           # from: p8 4 @ r9 -> fe 0f dc ba (little-endian)
N_FLAG    = 27                   # required input length (0x1B)

# ---- constants lifted from the binary ----
# If seed == 0, the code replaces it with 0xC001D00D (fallback). We keep it for reference.
FALLBACK_SEED = 0xC001D00D       # seen in decomp: if (uVar39 == 0) uVar39 = 0xc001d00d

def xorshift32(x: int) -> int:
    """One step of the PRNG used in S-box generation (<<13, >>17, <<5)."""
    x ^= (x << 13) & 0xFFFFFFFF
    x ^= (x >> 17) & 0xFFFFFFFF
    x ^= (x << 5)  & 0xFFFFFFFF
    return x & 0xFFFFFFFF

def make_sbox(seed: int) -> list:
    """
    Build the 256-byte S-box via Fisher-Yates shuffling driven by xorshift32.
    Decompiler: the long loop that repeatedly computes a PRNG value, mods by
    the remaining range, and swaps bytes (classic Fisher-Yates).
    """
    s = seed if seed != 0 else FALLBACK_SEED
    a = list(range(256))
    for i in range(255, 0, -1):
        s = xorshift32(s)
        j = s % (i + 1)
        a[i], a[j] = a[j], a[i]
    return a

def invert_table(t: list) -> list:
    """Compute inverse mapping of an S-box: inv[t[i]] = i."""
    inv = [0] * 256
    for i, v in enumerate(t):
        inv[v] = i
    return inv

def unmask_goal(masked: bytes) -> bytes:
    """
    Remove the per-index compare mask seen in the final loop:
        al = ((rbp[i] ^ ((i*0x0d) - 0x5a)) ^ 0x3c) & 0xff
        cmp al, [rsi + i]
    Rearranged => goal[i] = expected[i] ^ (((0xA6 + 13*i) & 0xFF) ^ 0x3C).
    So to get expected[i], XOR with that mask again.
    """
    out = bytearray(32)
    for i, b in enumerate(masked[:32]):
        mask = ((0xA6 + 13 * i) & 0xFF) ^ 0x3C
        out[i] = b ^ mask
    return bytes(out)

def main():
    # 1) read & unmask the 32-byte “expected” array that the program compares against
    masked_goal = GOAL_PATH.read_bytes()[:32]
    expected = unmask_goal(masked_goal)

    # 2) rebuild the S-box and its inverse
    sbox = make_sbox(SEED)
    inv  = invert_table(sbox)

    # 3) rebuild the 32-byte init table (SBOX[i] ^ 0x5A), as the binary does
    init = bytes((sbox[i] ^ 0x5A) for i in range(32))

    # 4) invert the VM’s per-byte update:
    #    vm: mem[i] ^= ( SBOX(flag[i]) ^ 0xA5 )
    #    and mem starts as init[i]. After the VM, it equals expected[i].
    #    So: SBOX(flag[i]) = expected[i] ^ init[i] ^ 0xA5
    #    => flag[i] = inv[ expected[i] ^ init[i] ^ 0xA5 ]
    flag_bytes = bytearray()
    for i in range(N_FLAG):
        want = expected[i] ^ init[i] ^ 0xA5
        flag_bytes.append(inv[want])

    flag = bytes(flag_bytes)

    # print both ascii (if decodable) and hex for safety
    print("recovered (hex):", flag.hex())
    try:
        print("recovered (ascii):", flag.decode("utf-8"))
    except UnicodeDecodeError:
        print("recovered (ascii):", flag)

    # optional: sanity check on the last 5 bytes (constants in the binary from r9 dump)
    tail_expected = [0x55, 0xAA, 0x11, 0x22, 0x33]
    ok = all((init[27+i] ^ tail_expected[i]) == expected[27+i] for i in range(5))
    if not ok:
        print("[!] trailing-constant check failed (flag may still be correct)")

if __name__ == "__main__":
    main()

